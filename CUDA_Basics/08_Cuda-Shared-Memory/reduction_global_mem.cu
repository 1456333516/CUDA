// =====================================================================
// CUDA归约操作 - 全局内存版本
// =====================================================================

// 条件编译：这是一个重要的编程技巧，让我们可以根据需要选择不同的数据精度
#ifdef USE_DP
    // 如果定义了USE_DP宏，就使用双精度浮点数
    typedef double real;           // double类型占用64位，精度更高但速度稍慢
    const real EPSILON = 1.0e-15;  // 双精度下的极小值，用于比较两个浮点数是否相等
#else
    // 如果没有定义USE_DP宏，就使用单精度浮点数（默认情况）
    typedef float real;            // float类型占用32位，速度快但精度较低
    const real EPSILON = 1.0e-6;   // 单精度下的极小值，用于浮点数比较
#endif

// =====================================================================
// CUDA内核函数：执行归约操作（求和）
// 归约的意思是把很多数字合并成一个结果，比如把数组中所有元素相加
// =====================================================================
void __global__ reduce_global(real *d_x, real *d_y)
{
    // 获取当前线程在线程块中的编号（0到blockDim.x-1）
    const int tid = threadIdx.x;
    
    // 计算当前线程块在全局数组中的起始位置
    // 注意：这里有个拼写错误，应该是blockDim.x而不是blockDinam.x
    real *x = d_x + blockDim.x * blockIdx.x;  // 指向当前块要处理的数据

    // =================================================================
    // 归约算法的核心部分：树形归约
    // 这是一个很巧妙的算法，通过不断将数据对半合并来快速求和
    // =================================================================
    
    // offset从线程块大小的一半开始，每次减半
    // 比如如果blockDim.x=128，那么offset依次是：64, 32, 16, 8, 4, 2, 1
    for(int offset = blockDim.x >> 1; offset > 0; offset >>= 1)
    {
        // 只有编号小于offset的线程才参与这次归约
        // 这样可以避免数组越界访问
        if(tid < offset)
        {
            // 核心操作：将两个元素相加
            // x[tid] += x[tid + offset] 表示：
            // 当前位置的值 加上 距离当前位置offset个位置的值
            x[tid] += x[tid + offset];
        }
    
        // 非常重要的同步点！
        // __syncthreads()确保同一个线程块中的所有线程都完成了当前步骤
        // 然后才能继续下一轮归约，这样保证计算的正确性
        __syncthreads();
    }
    
    // 当归约完成后，线程块中编号为0的线程将结果写回到全局内存
    if(tid == 0)
    {
        // 将当前块的归约结果存储到输出数组对应位置
        d_y[blockIdx.x] = x[0];  // x[0]现在包含了这个块所有元素的和
    }
}

// =====================================================================
// 算法工作原理举例说明（假设blockDim.x = 8）:
// 初始数据: [1][2][3][4][5][6][7][8]
//
// 第1轮 (offset=4): 
// [1+5][2+6][3+7][4+8][5][6][7][8] = [6][8][10][12][5][6][7][8]
//
// 第2轮 (offset=2):
// [6+10][8+12][10][12][5][6][7][8] = [16][20][10][12][5][6][7][8]
//
// 第3轮 (offset=1):
// [16+20][20][10][12][5][6][7][8] = [36][20][10][12][5][6][7][8]
//
// 最终结果: 36 （存储在x[0]中）
// =====================================================================
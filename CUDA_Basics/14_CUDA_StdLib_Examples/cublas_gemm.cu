#include "error.cuh"          // 包含自定义的CUDA错误检查宏CHECK
#include <stdio.h>            // 包含标准输入输出库
#include <cublas_v2.h>        // 包含cuBLAS库头文件（CUDA Basic Linear Algebra Subprograms）

/*
 * ==================== 程序功能说明 ====================
 * 这是一个使用cuBLAS库执行矩阵乘法的示例程序
 * 
 * 矩阵乘法公式：C = α × A × B + β × C
 * 在本例中：C = 1.0 × A × B + 0.0 × C = A × B
 * 
 * 矩阵维度说明：
 * A: M×K 矩阵 (2×3)
 * B: K×N 矩阵 (3×2)  
 * C: M×N 矩阵 (2×2)
 * 
 * cuBLAS的优势：
 * 1. 高度优化的CUDA实现，性能优异
 * 2. 工业级数值稳定性
 * 3. 支持多种数据类型（float, double, complex等）
 * 4. 广泛应用于科学计算和机器学习
 */

/*
 * 函数声明：打印矩阵内容
 * @param R: 矩阵行数
 * @param C: 矩阵列数
 * @param A: 指向矩阵数据的指针
 * @param name: 矩阵名称（用于显示）
 */
void print_matrix(int R, int C, double* A, const char* name);

int main(void)
{
    /*
     * ==================== 矩阵维度定义 ====================
     * 定义三个矩阵的维度参数
     */
    int M = 2;    // 矩阵A的行数，矩阵C的行数
    int K = 3;    // 矩阵A的列数，矩阵B的行数（内维度）
    int N = 2;    // 矩阵B的列数，矩阵C的列数
    
    /*
     * 计算各矩阵元素总数：
     * MK = M × K = 2 × 3 = 6 （矩阵A的元素个数）
     * KN = K × N = 3 × 2 = 6 （矩阵B的元素个数）
     * MN = M × N = 2 × 2 = 4 （矩阵C的元素个数）
     */
    int MK = M * K;  // 矩阵A的总元素数
    int KN = K * N;  // 矩阵B的总元素数
    int MN = M * N;  // 矩阵C的总元素数

    /*
     * ==================== 主机端内存分配 ====================
     * 在CPU内存中为三个矩阵分配存储空间
     */
    double *h_A = (double *)malloc(sizeof(double) * MK);  // 主机端矩阵A
    double *h_B = (double *)malloc(sizeof(double) * KN);  // 主机端矩阵B
    double *h_C = (double *)malloc(sizeof(double) * MN);  // 主机端矩阵C（结果矩阵）

    /*
     * ==================== 矩阵A数据初始化 ====================
     * 将矩阵A初始化为 [0, 1, 2, 3, 4, 5]
     * 按列优先顺序存储（这是cuBLAS的默认存储方式）
     * 
     * 矩阵A的实际布局（2×3）：
     * [0  2  4]
     * [1  3  5]
     */
    for (int i = 0; i < MK; i++)    // 遍历所有元素
    {
        h_A[i] = i;                 // 依次赋值0, 1, 2, 3, 4, 5
    }
    print_matrix(M, K, h_A, "A");   // 打印矩阵A的内容

    /*
     * ==================== 矩阵B数据初始化 ====================
     * 将矩阵B初始化为 [0, 1, 2, 3, 4, 5]
     * 同样按列优先顺序存储
     * 
     * 矩阵B的实际布局（3×2）：
     * [0  3]
     * [1  4]
     * [2  5]
     */
    for (int i = 0; i < KN; i++)    // 遍历所有元素
    {
        h_B[i] = i;                 // 依次赋值0, 1, 2, 3, 4, 5
    }
    print_matrix(K, N, h_B, "B");   // 打印矩阵B的内容

    /*
     * ==================== 矩阵C初始化 ====================
     * 将结果矩阵C初始化为全零矩阵
     * 这是矩阵乘法的良好实践，确保没有垃圾数据影响结果
     * 
     * 矩阵C的初始布局（2×2）：
     * [0  0]
     * [0  0]
     */
    for(int i = 0; i < MN; i++)     // 遍历所有元素
    {
        h_C[i] = 0;                 // 初始化为0
    }

    /*
     * ==================== GPU端内存分配 ====================
     * 在GPU显存中为三个矩阵分配存储空间
     * 使用CHECK宏确保分配成功，失败时会打印错误信息并退出
     */
    double *g_A, *g_B, *g_C;        // 声明GPU端指针（g_前缀表示gpu）
    
    CHECK(cudaMalloc((void **)&g_A, sizeof(double) * MK));  // 分配矩阵A的GPU内存
    CHECK(cudaMalloc((void **)&g_B, sizeof(double) * KN));  // 分配矩阵B的GPU内存
    CHECK(cudaMalloc((void **)&g_C, sizeof(double) * MN));  // 分配矩阵C的GPU内存

    /*
     * ==================== 数据传输：主机→设备 ====================
     * 使用cuBLAS提供的向量传输函数将数据从主机复制到设备
     * 
     * cublasSetVector参数说明：
     * - MK/KN/MN: 要传输的元素个数
     * - sizeof(double): 每个元素的字节数
     * - h_A/h_B/h_C: 源地址（主机端）
     * - 1: 主机端步长（连续存储，步长为1）
     * - g_A/g_B/g_C: 目标地址（设备端）
     * - 1: 设备端步长（连续存储，步长为1）
     */
    cublasSetVector(MK, sizeof(double), h_A, 1, g_A, 1);    // 传输矩阵A
    cublasSetVector(KN, sizeof(double), h_B, 1, g_B, 1);    // 传输矩阵B
    cublasSetVector(MN, sizeof(double), h_C, 1, g_C, 1);    // 传输矩阵C

    /*
     * ==================== cuBLAS句柄创建 ====================
     * cuBLAS句柄是使用cuBLAS函数必须的上下文对象
     * 它管理库的内部状态和资源
     */
    cublasHandle_t handle;          // 声明cuBLAS句柄
    cublasCreate(&handle);          // 创建并初始化句柄

    /*
     * ==================== 矩阵乘法参数设置 ====================
     * 定义矩阵乘法的标量系数
     * 
     * 公式：C = α × A × B + β × C
     * 在本例中：C = 1.0 × A × B + 0.0 × C = A × B
     */
    double alpha = 1.0;             // 矩阵乘积的系数
    double beta = 0.0;              // 结果矩阵的系数

    /*
     * ==================== 核心计算：cuBLAS矩阵乘法 ====================
     * 调用cuBLAS的双精度通用矩阵乘法函数
     * 
     * cublasDgemm参数详解：
     * handle: cuBLAS句柄
     * CUBLAS_OP_N: 矩阵A的操作（N=不转置，T=转置）
     * CUBLAS_OP_N: 矩阵B的操作（N=不转置，T=转置）
     * M: 矩阵C的行数（结果矩阵行数）
     * N: 矩阵C的列数（结果矩阵列数）
     * K: 内维度（A的列数 = B的行数）
     * &alpha: 标量α的指针
     * g_A: 矩阵A的数据指针
     * M: 矩阵A的主维度（行数）
     * g_B: 矩阵B的数据指针
     * K: 矩阵B的主维度（行数）
     * &beta: 标量β的指针
     * g_C: 矩阵C的数据指针（也是结果存储位置）
     * M: 矩阵C的主维度（行数）
     * 
     * 计算过程：
     * A(2×3) × B(3×2) = C(2×2)
     * [0 2 4]   [0 3]   [0×0+2×1+4×2  0×3+2×4+4×5]   [10 28]
     * [1 3 5] × [1 4] = [1×0+3×1+5×2  1×3+3×4+5×5] = [13 37]
     *           [2 5]
     */
    cublasDgemm(handle, CUBLAS_OP_N, CUBLAS_OP_N, M, N, K, 
                &alpha, g_A, M, g_B, K, &beta, g_C, M);

    /*
     * ==================== 清理cuBLAS资源 ====================
     * 销毁cuBLAS句柄，释放相关资源
     */
    cublasDestroy(handle);

    /*
     * ==================== 结果传输：设备→主机 ====================
     * 将计算结果从GPU显存复制回主机内存
     * 
     * cublasGetVector参数与cublasSetVector对应：
     * - MN: 要传输的元素个数
     * - sizeof(double): 每个元素的字节数
     * - g_C: 源地址（设备端）
     * - 1: 设备端步长
     * - h_C: 目标地址（主机端）
     * - 1: 主机端步长
     */
    cublasGetVector(MN, sizeof(double), g_C, 1, h_C, 1);

    /*
     * ==================== 结果输出 ====================
     * 打印最终的矩阵乘法结果
     */
    print_matrix(M, N, h_C, "C = A x B");

    /*
     * ==================== 内存清理 ====================
     * 释放所有分配的内存资源
     * 
     * 释放顺序：先释放主机内存，再释放设备内存
     */
    free(h_A);                      // 释放主机端矩阵A内存
    free(h_B);                      // 释放主机端矩阵B内存
    free(h_C);                      // 释放主机端矩阵C内存
    
    CHECK(cudaFree(g_A));           // 释放设备端矩阵A内存
    CHECK(cudaFree(g_B));           // 释放设备端矩阵B内存
    CHECK(cudaFree(g_C));           // 释放设备端矩阵C内存
    
    return 0;                       // 程序正常结束
}

/*
 * ==================== 矩阵打印函数实现 ====================
 * 按照列优先顺序打印矩阵内容
 * 
 * @param R: 矩阵行数
 * @param C: 矩阵列数
 * @param A: 指向矩阵数据的指针
 * @param name: 矩阵名称
 */
void print_matrix(int R, int C, double* A, const char* name)
{
    printf("%s = \n", name);        // 打印矩阵名称
    
    /*
     * 按行优先方式打印矩阵（便于人类阅读）
     * 但数据实际上按列优先存储
     * 
     * 访问公式：A[c * R + r]
     * - c * R: 第c列的起始偏移量
     * - r: 第r行的偏移量
     * - c * R + r: 第c列第r行元素的索引
     */
    for (int r = 0; r < R; r++)     // 遍历每一行
    {
        for (int c = 0; c < C; c++) // 遍历每一列
        {
            printf("%10.6f ", A[c * R + r]);  // 打印元素值，格式化为10位宽度，6位小数
        }
        printf("\n");               // 每行结束后换行
    }
}

/*
 * ==================== 预期输出 ====================
 * A = 
 *   0.000000   2.000000   4.000000 
 *   1.000000   3.000000   5.000000 
 * 
 * B = 
 *   0.000000   3.000000 
 *   1.000000   4.000000 
 *   2.000000   5.000000 
 * 
 * C = A x B = 
 *  10.000000  28.000000 
 *  13.000000  37.000000 
 * 
 * 验证计算：
 * C[0,0] = 0×0 + 2×1 + 4×2 = 10
 * C[0,1] = 0×3 + 2×4 + 4×5 = 28
 * C[1,0] = 1×0 + 3×1 + 5×2 = 13
 * C[1,1] = 1×3 + 3×4 + 5×5 = 37
 */

/*
 * ==================== 技术要点总结 ====================
 * 
 * 1. cuBLAS使用注意事项：
 *    - 默认使用列优先存储（Fortran风格）
 *    - 索引从0开始（C风格）
 *    - 必须正确管理句柄的创建和销毁
 * 
 * 2. 性能优化建议：
 *    - 尽量批量传输数据，减少内存传输次数
 *    - 重用cuBLAS句柄而不是频繁创建销毁
 *    - 合理选择数据类型（float vs double的性能差异）
 * 
 * 3. 与其他库的对比：
 *    - cuBLAS: NVIDIA官方库，性能最优
 *    - cuSPARSE: 专门处理稀疏矩阵
 *    - Thrust: 更高层次的抽象，使用简便
 *    - CUB: 低层次原语库，灵活性最高
 * 
 * 4. 实际应用场景：
 *    - 深度学习中的前向/反向传播
 *    - 科学计算中的线性方程组求解
 *    - 图像处理中的变换操作
 *    - 金融工程中的风险分析计算
 */
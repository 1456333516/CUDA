#include <stdio.h>        // 包含标准输入输出库
#include <stdlib.h>       // 包含标准库函数（malloc, calloc, free等）
#include <curand.h>       // 包含cuRAND随机数生成库头文件

/*
 * ==================== 程序功能说明 ====================
 * 这是一个使用cuRAND库在GPU上生成均匀分布随机数的示例程序
 * 
 * 程序主要功能：
 * 1. 使用GPU生成大量[0,1)区间内的双精度随机数
 * 2. 将随机数从GPU传输到主机
 * 3. 将结果保存到文本文件中供后续分析
 * 
 * cuRAND库特点：
 * 1. 专门为CUDA设计的随机数生成库
 * 2. 支持多种分布（均匀分布、正态分布、泊松分布等）
 * 3. 提供伪随机数和拟随机数生成器
 * 4. 高性能并行随机数生成
 * 
 * 应用场景：
 * - 蒙特卡洛模拟
 * - 机器学习训练数据生成
 * - 科学计算中的随机采样
 * - 游戏开发中的随机事件
 */

/*
 * 函数声明：输出结果到文件
 * @param N: 随机数个数
 * @param x: 指向随机数数组的指针
 */
void output_results(int N, double *x);

int main(void)
{
    /*
     * ==================== 随机数生成器创建 ====================
     * cuRAND使用生成器对象来管理随机数序列
     */
    curandGenerator_t generator;  // 声明随机数生成器句柄
    
    /*
     * 创建随机数生成器：
     * curandCreateGenerator(&generator, CURAND_RNG_PSEUDO_DEFAULT)
     * 
     * 参数说明：
     * - &generator: 指向生成器句柄的指针
     * - CURAND_RNG_PSEUDO_DEFAULT: 生成器类型
     *   可选类型包括：
     *   - CURAND_RNG_PSEUDO_DEFAULT: 默认伪随机数生成器
     *   - CURAND_RNG_PSEUDO_XORWOW: XORWOW算法
     *   - CURAND_RNG_QUASI_DEFAULT: 默认拟随机数生成器
     * 
     * 伪随机数 vs 拟随机数：
     * - 伪随机数：统计性质好，适合蒙特卡洛方法
     * - 拟随机数：分布更均匀，适合数值积分
     */
    curandCreateGenerator(&generator, CURAND_RNG_PSEUDO_DEFAULT);

    /*
     * ==================== 设置随机种子 ====================
     * 设置生成器的种子值，确保结果可重现
     * 
     * 重要性：
     * - 相同种子产生相同的随机序列
     * - 不同种子产生不同的随机序列
     * - 在调试和测试中非常有用
     */
    curandSetPseudoRandomGeneratorSeed(generator, 1234);  // 使用固定种子1234

    /*
     * ==================== 数据规模定义 ====================
     * 定义要生成的随机数个数
     */
    int N = 100000;  // 生成10万个随机数（较大的样本便于统计分析）

    /*
     * ==================== GPU内存分配 ====================
     * 在GPU显存中为随机数分配存储空间
     */
    double *g_x;  // GPU端指针（g_前缀表示GPU）
    
    /*
     * cudaMalloc参数说明：
     * - (void **)&g_x: 二级指针，用于接收分配的内存地址
     * - sizeof(double) * N: 分配的总字节数
     *   sizeof(double) = 8字节（双精度浮点数）
     *   N = 100000个数
     *   总计：8 × 100000 = 800000字节 ≈ 781KB
     */
    cudaMalloc((void **)&g_x, sizeof(double) * N);

    /*
     * ==================== 核心功能：生成随机数 ====================
     * 使用cuRAND生成均匀分布的双精度随机数
     * 
     * 函数：curandGenerateUniformDouble
     * 生成范围：[0.0, 1.0) 区间的均匀分布随机数
     * 
     * 参数详解：
     * - generator: 随机数生成器句柄
     * - g_x: 存储随机数的GPU内存指针
     * - N: 要生成的随机数个数
     * 
     * 执行过程：
     * 1. GPU并行生成N个随机数
     * 2. 每个线程独立生成自己的随机数
     * 3. 结果直接存储在指定的GPU内存中
     * 
     * 性能优势：
     * - 利用GPU数千个核心并行生成
     * - 比CPU串行生成快数十倍
     * - 适合大规模随机数生成需求
     */
    curandGenerateUniformDouble(generator, g_x, N);

    /*
     * ==================== 主机端内存分配 ====================
     * 在CPU内存中分配空间来接收GPU生成的随机数
     * 
     * calloc vs malloc：
     * - calloc: 分配内存并初始化为0
     * - malloc: 只分配内存，不初始化
     * 这里使用calloc是为了确保内存初始状态干净
     */
    double *x = (double *)calloc(N, sizeof(double));  // 主机端数组

    /*
     * ==================== 数据传输：GPU→CPU ====================
     * 将GPU生成的随机数复制到主机内存
     * 
     * cudaMemcpy参数说明：
     * - x: 目标地址（主机端）
     * - g_x: 源地址（设备端）
     * - sizeof(double) * N: 传输的数据量
     * - cudaMemcpyDeviceToHost: 传输方向（设备到主机）
     */
    cudaMemcpy(x, g_x, sizeof(double) * N, cudaMemcpyDeviceToHost);

    /*
     * ==================== GPU资源清理 ====================
     * 释放GPU端分配的内存
     * 及时释放资源是良好编程习惯
     */
    cudaFree(g_x);

    /*
     * ==================== 结果处理 ====================
     * 调用自定义函数将随机数保存到文件
     */
    output_results(N, x);

    /*
     * ==================== 主机资源清理 ====================
     * 释放主机端分配的内存
     */
    free(x);

    return 0;  // 程序正常结束
}

/*
 * ==================== 结果输出函数实现 ====================
 * 将随机数数组保存到文本文件中
 * 
 * @param N: 随机数个数
 * @param x: 指向随机数数组的指针
 */
void output_results(int N, double *x)
{
    /*
     * 文件操作：打开文件准备写入
     * fopen参数说明：
     * - "x1.txt": 文件名
     * - "w": 写入模式（如果文件存在则覆盖，不存在则创建）
     */
    FILE *fid = fopen("x1.txt", "w");  // 打开文件，返回文件指针
    
    /*
     * 逐个写入随机数到文件
     * 每个数字占一行，便于后续处理和分析
     */
    for(int n = 0; n < N; n++)         // 遍历所有随机数
    {
        /*
         * fprintf格式化输出：
         * - fid: 文件指针
         * - "%g\n": 格式字符串
         *   %g: 自动选择最合适的数字表示方式
         *   \n: 换行符
         * - x[n]: 要输出的数值
         */
        fprintf(fid, "%g\n", x[n]);    // 将第n个随机数写入文件
    }
    
    /*
     * 关闭文件：
     * 确保所有数据都被写入磁盘
     * 释放文件资源
     */
    fclose(fid);
}

/*
 * ==================== 预期输出文件内容示例 ====================
 * x1.txt文件内容（前几行）：
 * 0.629241
 * 0.165428
 * 0.841237
 * 0.329874
 * 0.915623
 * ...
 * （总共100000行）
 * 
 * 统计特性验证：
 * - 所有数值应在[0,1)区间内
 * - 平均值应接近0.5
 * - 方差应接近1/12 ≈ 0.0833
 * - 分布应该相对均匀
 */

/*
 * ==================== 技术要点总结 ====================
 * 
 * 1. cuRAND使用流程：
 *    创建生成器 → 设置种子 → 生成随机数 → 清理资源
 * 
 * 2. 内存管理原则：
 *    GPU分配 → GPU计算 → CPU传输 → CPU处理 → 释放内存
 * 
 * 3. 随机数质量检查：
 *    - 均匀性检验（卡方检验）
 *    - 独立性检验（游程检验）
 *    - 周期性检验
 * 
 * 4. 性能优化建议：
 *    - 批量生成而非逐个生成
 *    - 合理设置线程块大小
 *    - 减少主机-设备数据传输
 * 
 * 5. 其他可用的cuRAND函数：
 *    - curandGenerateNormalDouble(): 生成正态分布随机数
 *    - curandGeneratePoisson(): 生成泊松分布随机数
 *    - curandGenerateLogNormalDouble(): 生成对数正态分布随机数
 * 
 * 6. 实际应用场景：
 *    - 金融衍生品定价（蒙特卡洛模拟）
 *    - 物理仿真（粒子追踪）
 *    - 机器学习（数据增强、dropout）
 *    - 密码学（密钥生成）
 *    - 游戏开发（随机事件、AI决策）
 */

/*
 * ==================== 扩展练习建议 ====================
 * 
 * 1. 修改生成器类型：
 *    尝试使用不同的CURAND_RNG_*常量观察效果差异
 * 
 * 2. 改变种子值：
 *    使用时间戳作为种子实现真正的随机性
 * 
 * 3. 验证统计特性：
 *    编写代码计算生成随机数的均值、方差等统计量
 * 
 * 4. 生成其他分布：
 *    使用curandGenerateNormalDouble生成正态分布随机数
 * 
 * 5. 性能测试：
 *    测试不同N值下的生成时间和传输时间
 */